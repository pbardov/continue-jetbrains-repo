name: Build last 5 Continue (JetBrains) and publish to Pages

on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 3 * * 1"   # еженедельно (можно убрать)

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4

      - name: Set up Java 17 (for IntelliJ Gradle plugin)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Cache Gradle
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Prepare work dirs
        shell: bash
        run: |
          set -e
          rm -rf work site
          mkdir -p work site

      - name: Fetch tags from continuedev/continue
        id: tags
        shell: bash
        run: |
          set -euo pipefail
          TAGS=$(git ls-remote --tags --refs https://github.com/continuedev/continue.git \
            | awk '{print $2}' \
            | sed 's@refs/tags/@@' \
            | grep -E 'jetbrains$' \
            | sort -V -r \
            | head -n 5)

          echo "Selected tags:"
          echo "$TAGS"

          TAGS_PIPE=$(printf '%s\n' "$TAGS" | paste -sd'|' -)
          echo "tags=$TAGS_PIPE" >> "$GITHUB_OUTPUT"

      - name: Install NVM (global)  # доступен для последующих шагов через source
        shell: bash
        run: |
          set -euo pipefail
          export NVM_DIR="$HOME/.nvm"
          curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
          # Проверка
          . "$NVM_DIR/nvm.sh"
          nvm --version

      - name: Build each selected tag
        id: buildall
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${{ steps.tags.outputs.tags }}" ]; then
            echo "No tags selected; nothing to build" > site/README.txt
            exit 0
          fi

          IFS='|' read -r -a TAGS <<< "${{ steps.tags.outputs.tags }}"
          built_any=false

          for TAG in "${TAGS[@]}"; do
            echo "::group::Building $TAG"
            rm -rf work/continue
            git clone --depth=1 --branch "$TAG" https://github.com/continuedev/continue.git work/continue

            # === NVM: install & use Node version required by repo (.nvmrc) ===
            export NVM_DIR="$HOME/.nvm"
            . "$NVM_DIR/nvm.sh"
            # Если есть .nvmrc в корне — используем; иначе просто 'nvm install' подхватит LTS
            if [ -f work/continue/.nvmrc ]; then
              nvm install
              nvm use
            else
              nvm install --lts
              nvm use --lts
            fi
            node -v
            npm -v

            # === Обязательные зависимости по инструкции (CONTRIBUTING.md) ===
            if [ -x work/continue/scripts/install-dependencies.sh ]; then
              bash work/continue/scripts/install-dependencies.sh
            else
              echo "WARN: scripts/install-dependencies.sh not found/executable; continuing"
            fi

            # === autodetect IntelliJ module path ===
            PLUGIN_MODULE=""
            for CAND in "extensions/intellij" "plugins/intellij"; do
              if [ -f "work/continue/$CAND/gradlew" ]; then PLUGIN_MODULE="$CAND"; break; fi
            done
            if [ -z "$PLUGIN_MODULE" ]; then
              echo "IntelliJ module not found for $TAG; skipping"
              echo "::endgroup::"
              continue
            fi

            # === ensure config_schema.json is present at expected resource path (safety) ===
            SCHEMA_SRC=$(cd work/continue && git ls-files | grep -E '/config_schema\.json$' | head -n1 || true)
            SCHEMA_WANTED="work/continue/$PLUGIN_MODULE/src/main/resources/com/github/continuedev/continueintellijextension/continue/config_schema.json"
            mkdir -p "$(dirname "$SCHEMA_WANTED")"
            if [ -n "$SCHEMA_SRC" ]; then
              cp "work/continue/$SCHEMA_SRC" "$SCHEMA_WANTED"
              echo "Placed config_schema.json from repo"
            else
              echo 'Creating minimal fallback config_schema.json'
              printf '%s' '{"$schema":"http://json-schema.org/draft-07/schema#","type":"object"}' > "$SCHEMA_WANTED"
            fi

            # === build plugin ===
            pushd "work/continue/$PLUGIN_MODULE" >/dev/null
            ./gradlew --no-daemon buildPlugin
            popd >/dev/null

            ZIP=$(ls -1 "work/continue/$PLUGIN_MODULE/build/distributions"/*.zip 2>/dev/null | head -n1 || true)
            if [ -z "$ZIP" ]; then
              echo "No ZIP produced for $TAG, skipping"
              echo "::endgroup::"
              continue
            fi

            # --- Inspect and inject config_schema.json into ALL plugin JARs if missing ---
            TMP_DIR=work/inspect
            rm -rf "$TMP_DIR" && mkdir -p "$TMP_DIR/zip"
            unzip -q "$ZIP" -d "$TMP_DIR/zip"

            JARS=$(find "$TMP_DIR/zip" -type f -path '*/lib/*.jar' | sort)
            if [ -z "$JARS" ]; then
              echo "WARN: no JARs found inside plugin ZIP"
            else
              for J in $JARS; do
                if unzip -l "$J" | grep -q 'com/github/continuedev/continueintellijextension/continue/config_schema.json'; then
                  echo "OK: schema present in $(basename "$J")"
                else
                  echo "Injecting schema into $(basename "$J")"
                  WRK="$TMP_DIR/jarwrk"
                  rm -rf "$WRK" && mkdir -p "$WRK/com/github/continuedev/continueintellijextension/continue"
                  cp "$SCHEMA_WANTED" "$WRK/com/github/continuedev/continueintellijextension/continue/config_schema.json"
                  (cd "$WRK" && zip -q -u "$J" com/github/continuedev/continueintellijextension/continue/config_schema.json)
                fi
              done
            fi

            # Rebuild plugin ZIP from modified tree to ensure IDE receives updated JARs
            rm -f "$TMP_DIR/rebuilt.zip"
            (cd "$TMP_DIR/zip" && zip -q -r "$PWD/../rebuilt.zip" .)
            mv "$TMP_DIR/rebuilt.zip" "$ZIP"

            # Unpack for metadata extraction
            rm -rf work/extract && mkdir -p work/extract
            unzip -q "$ZIP" -d work/extract

            # Find plugin.xml either outside or inside lib/*.jar
            PLUGIN_XML=$(find work/extract -type f -path '*/META-INF/plugin.xml' | head -n1 || true)
            if [ -z "$PLUGIN_XML" ]; then
              JAR_WITH_XML=""
              while IFS= read -r J; do
                if unzip -l "$J" | grep -q 'META-INF/plugin.xml'; then
                  JAR_WITH_XML="$J"; break
                fi
              done < <(find work/extract -type f -path '*/lib/*.jar')

              if [ -n "$JAR_WITH_XML" ]; then
                unzip -p "$JAR_WITH_XML" META-INF/plugin.xml > work/extract/plugin.xml
                PLUGIN_XML="work/extract/plugin.xml"
              fi
            fi

            if [ -z "$PLUGIN_XML" ] || [ ! -s "$PLUGIN_XML" ]; then
              echo "plugin.xml not found for $TAG, skipping"
              echo "::endgroup::"
              continue
            fi

            # Parse metadata
            PLUGIN_ID=$(grep -oP '(?<=<id>)[^<]+' "$PLUGIN_XML" || true)
            if [ -z "$PLUGIN_ID" ]; then
              PLUGIN_ID=$(grep -oP '(?<=id=\")([^\"]+)' "$PLUGIN_XML" | head -n1 || true)
            fi
            PLUGIN_NAME=$(grep -oP '(?<=<name>)[^<]+' "$PLUGIN_XML" | head -n1 || true)
            PLUGIN_VERSION=$(grep -oP '(?<=<version>)[^<]+' "$PLUGIN_XML" | head -n1 || true)
            SINCE_BUILD=$(grep -oP '(?<=<idea-version[^>]*since-build=\")[^\"]+' "$PLUGIN_XML" | head -n1 || true)
            UNTIL_BUILD=$(grep -oP '(?<=<idea-version[^>]*until-build=\")[^\"]+' "$PLUGIN_XML" | head -n1 || true)

            echo "ID=$PLUGIN_ID NAME=$PLUGIN_NAME VERSION=$PLUGIN_VERSION since=$SINCE_BUILD until=$UNTIL_BUILD"

            # Publish ZIP to site
            cp "$ZIP" site/
            ZIP_NAME=$(basename "$ZIP")

            # Accumulate entries for updates.xml
            {
              echo "<plugin id=\"$PLUGIN_ID\" url=\"__BASE__/$ZIP_NAME\" version=\"$PLUGIN_VERSION\">"
              if [ -n "$SINCE_BUILD" ] || [ -n "$UNTIL_BUILD" ]; then
                printf "  <idea-version"
                [ -n "$SINCE_BUILD" ] && printf " since-build=\"%s\"" "$SINCE_BUILD"
                [ -n "$UNTIL_BUILD" ] && printf " until-build=\"%s\"" "$UNTIL_BUILD"
                echo " />"
              fi
              [ -n "$PLUGIN_NAME" ] && echo "  <name>$PLUGIN_NAME</name>"
              echo "</plugin>"
            } >> site/.plugins.tmp.xml

            built_any=true
            echo "::endgroup::"
          done

          if [ "$built_any" = false ]; then
            echo "WARNING: No plugins were successfully parsed; publishing empty updates.xml" >&2

      - name: Generate updates.xml
        shell: bash
        run: |
          set -euo pipefail
          OWNER="${GITHUB_REPOSITORY%/*}"
          REPO="${GITHUB_REPOSITORY#*/}"
          BASE_URL="https://${OWNER}.github.io/${REPO}"

          if [ -s site/.plugins.tmp.xml ]; then
            sed "s#__BASE__#${BASE_URL}#g" site/.plugins.tmp.xml > site/.plugins.ready.xml
          else
            : > site/.plugins.ready.xml
          fi

          {
            echo "<plugins>"
            cat site/.plugins.ready.xml
            echo "</plugins>"
          } > site/updates.xml

          echo "updates.xml:"
          cat site/updates.xml

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: site

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
