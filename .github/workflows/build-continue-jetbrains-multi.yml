name: Build last 5 Continue (JetBrains) and publish to Pages

on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 3 * * 1"   # еженедельно (можно убрать)

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4

      - name: Set up Java 17 (for IntelliJ Gradle plugin)
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Cache Gradle
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Prepare work dirs
        shell: bash
        run: |
          set -e
          rm -rf work site
          mkdir -p work site

      - name: Fetch last 5 *jetbrains tags from continuedev/continue
        id: tags
        shell: bash
        run: |
          set -euo pipefail
          TAGS=$(git ls-remote --tags --refs https://github.com/continuedev/continue.git \
            | awk '{print $2}' \
            | sed 's@refs/tags/@@' \
            | grep -E 'jetbrains$' \
            | sort -V -r \
            | head -n 5)
          echo "Selected tags:"; echo "$TAGS"
          echo "tags=$(printf '%s\n' "$TAGS" | paste -sd'|' -)" >> "$GITHUB_OUTPUT"

      - name: Install NVM
        shell: bash
        run: |
          set -euo pipefail
          export NVM_DIR="$HOME/.nvm"
          curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
          . "$NVM_DIR/nvm.sh"
          nvm --version

      - name: Build each selected tag
        id: buildall
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${{ steps.tags.outputs.tags }}" ]; then
            echo "No tags selected; nothing to build" > site/README.txt
            exit 0
          fi

          IFS='|' read -r -a TAGS <<< "${{ steps.tags.outputs.tags }}"
          built_any=false

          for TAG in "${TAGS[@]}"; do
            echo "::group::Building $TAG"
            rm -rf work/continue
            git clone --depth=1 --branch "$TAG" https://github.com/continuedev/continue.git work/continue

            # === NVM: install & use version from .nvmrc (fallback LTS) ===
            export NVM_DIR="$HOME/.nvm"
            . "$NVM_DIR/nvm.sh"
            if [ -f work/continue/.nvmrc ]; then
              DESIRED="$(tr -d ' \t\r\n' < work/continue/.nvmrc)"
            else
              DESIRED="lts/*"
            fi
            [ -z "$DESIRED" ] && DESIRED="lts/*"
            echo "Using Node via nvm: $DESIRED"
            if ! nvm install "$DESIRED"; then
              echo "WARN: nvm install '$DESIRED' failed, falling back to LTS"
              nvm install --lts
              DESIRED="lts/*"
            fi
            nvm use "$DESIRED" || nvm use --lts
            corepack enable || true
            corepack prepare pnpm@latest --activate || true
            node -v
            npm -v

            # === Repo-required dependencies (per CONTRIBUTING.md) ===
            if [ -f work/continue/scripts/install-dependencies.sh ]; then
              chmod +x work/continue/scripts/install-dependencies.sh
              (cd work/continue && bash scripts/install-dependencies.sh)
            else
              echo "WARN: scripts/install-dependencies.sh not found; continuing"
            fi

            # === autodetect IntelliJ module path ===
            PLUGIN_MODULE=""
            for CAND in "extensions/intellij" "plugins/intellij"; do
              if [ -f "work/continue/$CAND/gradlew" ]; then PLUGIN_MODULE="$CAND"; break; fi
            done
            if [ -z "$PLUGIN_MODULE" ]; then
              echo "IntelliJ module not found for $TAG; skipping"
              echo "::endgroup::"
              continue
            fi

            # === Ensure schemas exist in resources (both pkg path and root) ===
            SRC_DIR="work/continue/$PLUGIN_MODULE/src/main/resources"
            PKG_DIR="$SRC_DIR/com/github/continuedev/continueintellijextension/continue"
            mkdir -p "$PKG_DIR"
            for F in config_schema.json continue_rc_schema.json; do
              FOUND=$(cd work/continue && git ls-files | grep -E "/$F$" | head -n1 || true)
              if [ -n "$FOUND" ]; then
                cp "work/continue/$FOUND" "$PKG_DIR/$F"
                cp "work/continue/$FOUND" "$SRC_DIR/$F"
              else
                echo "WARN: $F not found in repo; creating minimal fallback"
                printf '%s' '{"$schema":"http://json-schema.org/draft-07/schema#","type":"object"}' > "$PKG_DIR/$F"
                cp "$PKG_DIR/$F" "$SRC_DIR/$F"
              fi
            done

            # === build plugin ===
            pushd "work/continue/$PLUGIN_MODULE" >/dev/null
            ./gradlew --no-daemon buildPlugin
            popd >/dev/null

            ZIP=$(ls -1 "work/continue/$PLUGIN_MODULE/build/distributions"/*.zip 2>/dev/null | head -n1 || true)
            if [ -z "$ZIP" ]; then
              echo "No ZIP produced for $TAG, skipping"
              echo "::endgroup::"
              continue
            fi

            # --- Inspect and REBUILD ALL plugin JARs with schemas (no in-place jar uf) ---
            TMP_DIR=work/inspect
            rm -rf "$TMP_DIR" && mkdir -p "$TMP_DIR/zip"
            unzip -q "$ZIP" -d "$TMP_DIR/zip"

            mapfile -t JARS < <(find "$TMP_DIR/zip" -type f -path '*/lib/*.jar' | sort)
            if [ "${#JARS[@]}" -eq 0 ]; then
              echo "WARN: no JARs found inside plugin ZIP"
            else
              SHADOW="$TMP_DIR/shadow"
              mkdir -p "$SHADOW/com/github/continuedev/continueintellijextension/continue"
              cp "$PKG_DIR/config_schema.json" "$SHADOW/com/github/continuedev/continueintellijextension/continue/config_schema.json"
              cp "$PKG_DIR/continue_rc_schema.json" "$SHADOW/com/github/continuedev/continueintellijextension/continue/continue_rc_schema.json"
              cp "$PKG_DIR/config_schema.json" "$SHADOW/config_schema.json"
              cp "$PKG_DIR/continue_rc_schema.json" "$SHADOW/continue_rc_schema.json"

              for J in "${JARS[@]}"; do
                echo "Rebuilding $(basename "$J") with schemas (if missing)"

                WRK="$TMP_DIR/jarwrk"
                rm -rf "$WRK" && mkdir -p "$WRK"
                unzip -q "$J" -d "$WRK"

                # copy schemas into both paths (overwrite or add)
                mkdir -p "$WRK/com/github/continuedev/continueintellijextension/continue"
                cp "$SHADOW/com/github/continuedev/continueintellijextension/continue/config_schema.json" "$WRK/com/github/continuedev/continueintellijextension/continue/config_schema.json"
                cp "$SHADOW/com/github/continuedev/continueintellijextension/continue/continue_rc_schema.json" "$WRK/com/github/continuedev/continueintellijextension/continue/continue_rc_schema.json"
                cp "$SHADOW/config_schema.json" "$WRK/config_schema.json"
                cp "$SHADOW/continue_rc_schema.json" "$WRK/continue_rc_schema.json"

                # Recreate jar: сначала собираем внутри $WRK, затем атомарно переносим поверх исходного
                JDIR="$(dirname "$J")"
                JBASE="$(basename "$J")"
                NEWJ_LOCAL="$WRK/__rebuilt__.jar"

                rm -f "$NEWJ_LOCAL"
                # -X: не сохранять extra attrs, -r: рекурсивно, -q: тихо
                (cd "$WRK" && zip -q -X -r "__rebuilt__.jar" .)

                # Переносим готовый jar на место оригинала
                mv -f "$NEWJ_LOCAL" "$J"
              done
            fi

            # Rebuild plugin ZIP from modified tree
            rm -f "$TMP_DIR/rebuilt.zip"
            (cd "$TMP_DIR/zip" && zip -q -r "$PWD/../rebuilt.zip" .)
            mv "$TMP_DIR/rebuilt.zip" "$ZIP"

            # Unpack for metadata extraction
            rm -rf work/extract && mkdir -p work/extract
            unzip -q "$ZIP" -d work/extract

            # Find plugin.xml either outside or inside lib/*.jar
            PLUGIN_XML=$(find work/extract -type f -path '*/META-INF/plugin.xml' | head -n1 || true)
            if [ -z "$PLUGIN_XML" ]; then
              JAR_WITH_XML=""
              while IFS= read -r J; do
                if unzip -l "$J" | grep -q 'META-INF/plugin.xml'; then
                  JAR_WITH_XML="$J"; break
                fi
              done < <(find work/extract -type f -path '*/lib/*.jar')

              if [ -n "$JAR_WITH_XML" ]; then
                unzip -p "$JAR_WITH_XML" META-INF/plugin.xml > work/extract/plugin.xml
                PLUGIN_XML="work/extract/plugin.xml"
              fi
            fi

            if [ -z "$PLUGIN_XML" ] || [ ! -s "$PLUGIN_XML" ]; then
              echo "plugin.xml not found for $TAG, skipping"
              echo "::endgroup::"
              continue
            fi

            # Parse metadata (no lookbehind)
            PLUGIN_ID=$(perl -ne 'if(/<id>([^<]+)/){print $1;exit} if(/id="([^"]+)/){print $1;exit}' "$PLUGIN_XML")
            PLUGIN_NAME=$(perl -ne 'if(/<name>([^<]+)/){print $1;exit}' "$PLUGIN_XML")
            PLUGIN_VERSION=$(perl -ne 'if(/<version>([^<]+)/){print $1;exit}' "$PLUGIN_XML")
            SINCE_BUILD=$(perl -ne 'if(/since-build="([^"]+)/){print $1;exit}' "$PLUGIN_XML")
            UNTIL_BUILD=$(perl -ne 'if(/until-build="([^"]+)/){print $1;exit}' "$PLUGIN_XML")

            echo "ID=$PLUGIN_ID NAME=$PLUGIN_NAME VERSION=$PLUGIN_VERSION since=$SINCE_BUILD until=$UNTIL_BUILD"

            # Publish ZIP to site
            cp "$ZIP" site/
            ZIP_NAME=$(basename "$ZIP")

            # Accumulate entries for updates.xml
            {
              echo "<plugin id=\"$PLUGIN_ID\" url=\"__BASE__/$ZIP_NAME\" version=\"$PLUGIN_VERSION\">"
              if [ -n "$SINCE_BUILD" ] || [ -n "$UNTIL_BUILD" ]; then
                printf "  <idea-version"
                [ -n "$SINCE_BUILD" ] && printf " since-build=\"%s\"" "$SINCE_BUILD"
                [ -n "$UNTIL_BUILD" ] && printf " until-build=\"%s\"" "$UNTIL_BUILD"
                echo " />"
              fi
              [ -n "$PLUGIN_NAME" ] && echo "  <name>$PLUGIN_NAME</name>"
              echo "</plugin>"
            } >> site/.plugins.tmp.xml

            built_any=true
            echo "::endgroup::"
          done

          if [ "$built_any" = false ]; then
            echo "WARNING: No plugins were successfully parsed; publishing empty updates.xml" >&2
          fi

      - name: Generate updates.xml
        shell: bash
        run: |
          set -euo pipefail
          OWNER="${GITHUB_REPOSITORY%/*}"
          REPO="${GITHUB_REPOSITORY#*/}"
          BASE_URL="https://${OWNER}.github.io/${REPO}"

          if [ -s site/.plugins.tmp.xml ]; then
            sed "s#__BASE__#${BASE_URL}#g" site/.plugins.tmp.xml > site/.plugins.ready.xml
          else
            : > site/.plugins.ready.xml
          fi

          {
            echo "<plugins>"
            cat site/.plugins.ready.xml
            echo "</plugins>"
          } > site/updates.xml

          echo "updates.xml:"
          cat site/updates.xml

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: site

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
