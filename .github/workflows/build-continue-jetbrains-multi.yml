name: Build last 5 Continue (JetBrains) and publish to Pages

on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 3 * * 1"   # еженедельно (можно убрать)

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Cache Gradle
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Prepare work dirs
        shell: bash
        run: |
          set -e
          rm -rf work site
          mkdir -p work site

      - name: Fetch tags from continuedev/continue
        id: tags
        shell: bash
        run: |
          set -euo pipefail
          TAGS=$(git ls-remote --tags --refs https://github.com/continuedev/continue.git \
            | awk '{print $2}' \
            | sed 's@refs/tags/@@' \
            | grep -E 'jetbrains$' \
            | sort -V -r \
            | head -n 5)

          echo "Selected tags:"; echo "$TAGS"
          TAGS_PIPE=$(echo "$TAGS" | tr '
' '|' | sed 's/|$//')
          echo "tags=$TAGS_PIPE" >> "$GITHUB_OUTPUT"

      - name: Build each selected tag
        id: buildall
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${{ steps.tags.outputs.tags }}" ]; then
            echo "No tags selected; nothing to build" > site/README.txt
            exit 0
          fi

          IFS='|' read -r -a TAGS <<< "${{ steps.tags.outputs.tags }}"
          built_any=false

          for TAG in "${TAGS[@]}"; do
            echo "::group::Building $TAG"
            rm -rf work/continue
            git clone --depth=1 --branch "$TAG" https://github.com/continuedev/continue.git work/continue

            # === autodetect IntelliJ module path ===
            PLUGIN_MODULE=""
            for CAND in "extensions/intellij" "plugins/intellij"; do
              if [ -f "work/continue/$CAND/gradlew" ]; then PLUGIN_MODULE="$CAND"; break; fi
            done
            if [ -z "$PLUGIN_MODULE" ]; then
              echo "IntelliJ module not found for $TAG; skipping"
              echo "::endgroup::"; continue
            fi

            # === ensure config_schema.json is present at expected resource path ===
            # Locate any config_schema.json in repo
            SCHEMA_SRC=$(cd work/continue && git ls-files | grep -E '/config_schema\.json$' | head -n1 || true)
            SCHEMA_WANTED="work/continue/$PLUGIN_MODULE/src/main/resources/com/github/continuedev/continueintellijextension/continue/config_schema.json"
            if [ -n "$SCHEMA_SRC" ]; then
              mkdir -p "$(dirname "$SCHEMA_WANTED")"
              cp "work/continue/$SCHEMA_SRC" "$SCHEMA_WANTED"
              echo "Placed config_schema.json at resources path"
            else
              echo "WARN: config_schema.json not found in repo; plugin may fail at runtime"
            fi

            pushd "work/continue/$PLUGIN_MODULE" >/dev/null
            ./gradlew --no-daemon buildPlugin
            popd >/dev/null

            ZIP=$(ls -1 "work/continue/$PLUGIN_MODULE/build/distributions"/*.zip 2>/dev/null | head -n1 || true)
            if [ -z "$ZIP" ]; then
              echo "No ZIP produced for $TAG, skipping"
              echo "::endgroup::"
              continue
            fi

            # verify config_schema.json exists inside produced ZIP (within JAR)
            if ! unzip -l "$ZIP" | grep -q 'lib/.*\.jar'; then
              echo "WARN: no JARs found inside plugin ZIP"
            else
              # check inside first jar for the schema (best-effort)
              FIRST_JAR=$(unzip -Z1 "$ZIP" | grep '^lib/.*\.jar$' | head -n1 || true)
              if [ -n "$FIRST_JAR" ]; then
                TMP_DIR=work/inspect
                rm -rf "$TMP_DIR" && mkdir -p "$TMP_DIR"
                unzip -q "$ZIP" "$FIRST_JAR" -d "$TMP_DIR"
                if ! unzip -p "$TMP_DIR/$FIRST_JAR" META-INF/plugin.xml >/dev/null 2>&1; then :; fi
                if ! unzip -p "$TMP_DIR/$FIRST_JAR" com/github/continuedev/continueintellijextension/continue/config_schema.json >/dev/null 2>&1; then
                  echo "WARN: config_schema.json not found inside JAR (may break JSON schema provider)"
                else
                  echo "OK: config_schema.json present inside JAR"
                fi
              fi
            fi

            # Unpack ZIP to extract metadata
            rm -rf work/extract && mkdir -p work/extract
            unzip -q "$ZIP" -d work/extract

            # Find plugin.xml either outside or inside lib/*.jar
            PLUGIN_XML=$(find work/extract -type f -path '*/META-INF/plugin.xml' | head -n1 || true)
            if [ -z "$PLUGIN_XML" ]; then
              JAR_WITH_XML=""
              while IFS= read -r J; do
                if unzip -l "$J" | grep -q 'META-INF/plugin.xml'; then
                  JAR_WITH_XML="$J"; break
                fi
              done < <(find work/extract -type f -path '*/lib/*.jar')

              if [ -n "$JAR_WITH_XML" ]; then
                unzip -p "$JAR_WITH_XML" META-INF/plugin.xml > work/extract/plugin.xml
                PLUGIN_XML="work/extract/plugin.xml"
              fi
            fi

            if [ -z "$PLUGIN_XML" ] || [ ! -s "$PLUGIN_XML" ]; then
              echo "plugin.xml not found for $TAG, skipping"
              echo "::endgroup::"
              continue
            fi

            # Parse metadata
            PLUGIN_ID=$(grep -oP '(?<=<id>)[^<]+' "$PLUGIN_XML" || true)
            if [ -z "$PLUGIN_ID" ]; then
              PLUGIN_ID=$(grep -oP '(?<=id=")([^"]+)' "$PLUGIN_XML" | head -n1 || true)
            fi
            PLUGIN_NAME=$(grep -oP '(?<=<name>)[^<]+' "$PLUGIN_XML" | head -n1 || true)
            PLUGIN_VERSION=$(grep -oP '(?<=<version>)[^<]+' "$PLUGIN_XML" | head -n1 || true)
            SINCE_BUILD=$(grep -oP '(?<=<idea-version[^>]*since-build=")[^"]+' "$PLUGIN_XML" | head -n1 || true)
            UNTIL_BUILD=$(grep -oP '(?<=<idea-version[^>]*until-build=")[^"]+' "$PLUGIN_XML" | head -n1 || true)

            echo "ID=$PLUGIN_ID NAME=$PLUGIN_NAME VERSION=$PLUGIN_VERSION since=$SINCE_BUILD until=$UNTIL_BUILD"

            # Copy ZIP to site
            cp "$ZIP" site/
            ZIP_NAME=$(basename "$ZIP")

            # Accumulate entries for updates.xml
            {
              echo "<plugin id=\"$PLUGIN_ID\" url=\"__BASE__/$ZIP_NAME\" version=\"$PLUGIN_VERSION\">"
              if [ -n "$SINCE_BUILD" ] || [ -n "$UNTIL_BUILD" ]; then
                printf "  <idea-version"
                [ -n "$SINCE_BUILD" ] && printf " since-build=\"%s\"" "$SINCE_BUILD"
                [ -n "$UNTIL_BUILD" ] && printf " until-build=\"%s\"" "$UNTIL_BUILD"
                echo " />"
              fi
              [ -n "$PLUGIN_NAME" ] && echo "  <name>$PLUGIN_NAME</name>"
              echo "</plugin>"
            } >> site/.plugins.tmp.xml

            built_any=true
            echo "::endgroup::"
          done

          if [ "$built_any" = false ]; then
            echo "WARNING: No plugins were successfully parsed; publishing empty updates.xml" >&2
          fi

      - name: Generate updates.xml
        shell: bash
        run: |
          set -euo pipefail
          OWNER="${GITHUB_REPOSITORY%/*}"
          REPO="${GITHUB_REPOSITORY#*/}"
          BASE_URL="https://${OWNER}.github.io/${REPO}"

          if [ -s site/.plugins.tmp.xml ]; then
            sed "s#__BASE__#${BASE_URL}#g" site/.plugins.tmp.xml > site/.plugins.ready.xml
          else
            : > site/.plugins.ready.xml
          fi

          {
            echo "<plugins>"
            cat site/.plugins.ready.xml
            echo "</plugins>"
          } > site/updates.xml

          echo "updates.xml:"; cat site/updates.xml

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: site

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
